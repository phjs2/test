<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>업비트 SOL/KRW 시세 분석</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      margin: 0;
      padding: 1rem;
      background: #f2f2f2;
    }

    .container {
      max-width: 720px;
      margin: auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 1.5rem;
    }

    
    h2 {
      text-align: center;
      font-size: 1.05rem;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 1rem;
    }
    

    pre {
      white-space: pre-wrap;
      word-break: break-word;
      font-size: 1rem;
      line-height: 1.6;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div class="container">
    <h2>📊 업비트 SOL/KRW 시세 분석 (1일봉)</h2>
    <canvas id="priceChart" style="max-width: 100%; height: 400px;"></canvas>
    <pre id="output">조회 중...</pre>
  </div>

  <script>
    async function fetchWithRetry(retries = 3, delay = 1000) {
      for (let i = 0; i < retries; i++) {
        try {
          return await fetch(`https://api.upbit.com/v1/candles/days?market=KRW-SOL&count=200`);
        } catch (err) {
          if (i < retries - 1) await new Promise(res => setTimeout(res, delay));
          else throw err;
        }
      }
    }

    async function fetchData() {
      const output = document.getElementById('output');
      output.textContent = '조회 중...';

      try {
        const now = new Date().toLocaleString();
        const res = await fetchWithRetry();
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const candles = await res.json();
        const closes = candles.map(c => c.trade_price).reverse();

        const sma = (arr, len) => {
          const out = [];
          for (let i = len - 1; i < arr.length; i++) {
            const slice = arr.slice(i - len + 1, i + 1);
            out.push(slice.reduce((a, b) => a + b, 0) / len);
          }
          return out;
        };

        const EMA = (data, period) => {
          const k = 2 / (period + 1);
          const ema = [data[0]];
          for (let i = 1; i < data.length; i++) {
            ema.push(data[i] * k + ema[i - 1] * (1 - k));
          }
          return ema;
        };

        const ema12 = EMA(closes, 12);
        const ema26 = EMA(closes, 26);
        const macdLine = ema12.map((val, i) => val - ema26[i]);
        const signalLine = EMA(macdLine.slice(ema26.length - macdLine.length), 9);
        const latestMACD = macdLine.at(-1);
        const latestMACDSignal = signalLine.at(-1);
        const cross = latestMACD > latestMACDSignal ? '골든크로스' : '데드크로스';

        const rsiPeriod = 14;
        const rsiValues = [];
        let gainSum = 0, lossSum = 0;

        for (let i = 1; i <= rsiPeriod; i++) {
          const diff = closes[i] - closes[i - 1];
          if (diff >= 0) gainSum += diff;
          else lossSum -= diff;
        }

        let avgGain = gainSum / rsiPeriod;
        let avgLoss = lossSum / rsiPeriod;
        rsiValues.push(100 - (100 / (1 + avgGain / avgLoss)));

        for (let i = rsiPeriod + 1; i < closes.length; i++) {
          const diff = closes[i] - closes[i - 1];
          const gain = diff > 0 ? diff : 0;
          const loss = diff < 0 ? -diff : 0;

          avgGain = (avgGain * (rsiPeriod - 1) + gain) / rsiPeriod;
          avgLoss = (avgLoss * (rsiPeriod - 1) + loss) / rsiPeriod;

          const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
          rsiValues.push(100 - (100 / (1 + rs)));
        }

        const rsiSignalArr = EMA(rsiValues, 9);
        const latestRSI = rsiValues.at(-1);
        const latestSignal = rsiSignalArr.at(-1);

        const ma5 = sma(closes, 5).at(-1).toFixed(0);
        const ma20 = sma(closes, 20).at(-1).toFixed(0);
        const ma60 = sma(closes, 60).at(-1).toFixed(0);
        const ma120 = sma(closes, 120).at(-1).toFixed(0);
        const ma200 = sma(closes, 200).at(-1).toFixed(0);

        const volume = candles[0].candle_acc_trade_volume.toFixed(2);
        const currentPrice = closes.at(-1).toLocaleString();

        output.textContent = `
📅 날짜: ${now}
📊 차트: 업비트 SOL/KRW / 1일봉
💰 현재가: ${currentPrice} KRW
📈 이동평균선:
- 5일선: ${ma5}
- 20일선: ${ma20}
- 60일선: ${ma60}
- 120일선: ${ma120}
- 200일선: ${ma200}
📉 RSI: ${latestRSI.toFixed(2)} / 시그널: ${latestSignal.toFixed(2)}
📉 MACD: ${latestMACD.toFixed(2)} / 시그널: ${latestMACDSignal.toFixed(2)} → ${cross}
📊 거래량: ${volume} SOL
        `;

        const dataMA5 = sma(closes, 5).slice(-60);
        const dataMA20 = sma(closes, 20).slice(-60);
        const dataMA60 = sma(closes, 60).slice(-60);
        const dataMA120 = sma(closes, 120).slice(-60);
        const dataMA200 = sma(closes, 200).slice(-60);
        const dataClose = closes.slice(-60);
        const labels = candles.map(c => c.candle_date_time_kst.slice(0, 10)).reverse().slice(-60);

        const ctx = document.getElementById('priceChart').getContext('2d');
        new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [
              {
                label: '종가',
                data: dataClose,
                borderColor: 'blue',
                borderWidth: 2,
                tension: 0.2
              },
              {
                label: '5일선',
                data: dataMA5,
                borderColor: 'green',
                borderWidth: 1,
                borderDash: [5, 5],
                tension: 0.2
              },
              {
                label: '20일선',
                data: dataMA20,
                borderColor: 'orange',
                borderWidth: 1,
                borderDash: [5, 5],
                tension: 0.2
              },
              {
                label: '60일선',
                data: dataMA60,
                borderColor: 'purple',
                borderWidth: 1,
                borderDash: [5, 5],
                tension: 0.2
              },
              {
                label: '120일선',
                data: dataMA120,
                borderColor: 'brown',
                borderWidth: 1,
                borderDash: [5, 5],
                tension: 0.2
              },
              {
                label: '200일선',
                data: dataMA200,
                borderColor: 'gray',
                borderWidth: 1,
                borderDash: [5, 5],
                tension: 0.2
              }
            ]
          },
          options: {
            responsive: true,
            plugins: {
              legend: { position: 'top' },
              title: { display: true, text: 'SOL/KRW 종가 및 이동평균선' }
            },
            scales: {
              x: { ticks: { maxTicksLimit: 10 } }
            }
          }
        });

      } catch (err) {
        output.textContent = `🚨 데이터 조회 실패: ${err.message}`;
        console.error('데이터 가져오기 실패:', err);
      }
    }

    // ✅ 새로고침 때 잠깐 딜레이 주고 실행
    setTimeout(fetchData, 500);
  </script>
</body>
</html>
